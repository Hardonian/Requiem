#!/usr/bin/env node
/**
 * Doppler Sync Script
 *
 * Pulls environment variables from Doppler and exports them for runtime use.
 * Fails loudly if required secrets are missing.
 *
 * Usage:
 *   node scripts/sync-env.ts              # Sync and print available vars
 *   node scripts/sync-env.ts --check      # Only check if vars exist
 *   node scripts/sync-env.ts --export     # Export to .env file
 *
 * Required environment variables:
 *   - DOPPLER_TOKEN: Doppler service token
 *
 * Required secrets (checked after sync):
 *   - SUPABASE_URL
 *   - SUPABASE_SERVICE_ROLE_KEY
 *   - DATABASE_URL
 *   - DIRECT_DATABASE_URL
 *   - NEXT_PUBLIC_SUPABASE_URL
 *   - NEXT_PUBLIC_SUPABASE_ANON_KEY
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = join(__dirname, '..');

interface DopplerConfig {
  project: string;
  config: string;
}

interface SecretCheck {
  key: string;
  required: boolean;
  public?: boolean;
}

// Default required secrets to check
const REQUIRED_SECRETS: SecretCheck[] = [
  { key: 'SUPABASE_URL', required: true },
  { key: 'SUPABASE_SERVICE_ROLE_KEY', required: true },
  { key: 'DATABASE_URL', required: true },
  { key: 'DIRECT_DATABASE_URL', required: true },
  { key: 'NEXT_PUBLIC_SUPABASE_URL', required: true, public: true },
  { key: 'NEXT_PUBLIC_SUPABASE_ANON_KEY', required: true, public: true },
];

/**
 * Check if Doppler CLI is installed
 */
async function checkDopplerInstalled(): Promise<boolean> {
  try {
    const { execSync } = await import('child_process');
    execSync('doppler --version', { stdio: 'ignore' });
    return true;
  } catch {
    return false;
  }
}

/**
 * Fetch secrets from Doppler
 */
async function fetchDopplerSecrets(config: DopplerConfig): Promise<Record<string, string>> {
  const { execSync } = await import('child_process');

  try {
    const json = execSync(
      `doppler secrets download --project ${config.project} --config ${config.config} --format json`,
      {
        encoding: 'utf-8',
        env: { ...process.env }
      }
    );

    return JSON.parse(json);
  } catch (error) {
    console.error('Failed to fetch secrets from Doppler:', error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

/**
 * Validate required secrets are present
 */
function validateSecrets(secrets: Record<string, string>): { valid: boolean; missing: string[] } {
  const missing: string[] = [];

  for (const secret of REQUIRED_SECRETS) {
    if (secret.required && !secrets[secret.key]) {
      missing.push(secret.key);
    }
  }

  return {
    valid: missing.length === 0,
    missing,
  };
}

/**
 * Print secrets summary (without values)
 */
function printSecretsSummary(secrets: Record<string, string>): void {
  console.log('\nüìã Available environment variables:');
  console.log('‚îÄ'.repeat(40));

  for (const secret of REQUIRED_SECRETS) {
    const value = secrets[secret.key];
    const status = value ? '‚úÖ Set' : '‚ùå Missing';
    const visibility = secret.public ? '(public)' : '(secret)';
    console.log(`  ${secret.key} ${visibility} ${status}`);
  }

  console.log('‚îÄ'.repeat(40));
}

/**
 * Export secrets to .env file
 */
function exportToEnvFile(secrets: Record<string, string>, outputPath: string): void {
  const lines: string[] = [
    '# Generated by Doppler sync script',
    `# Created at: ${new Date().toISOString()}`,
    '',
  ];

  for (const [key, value] of Object.entries(secrets)) {
    if (value) {
      lines.push(`${key}=${value}`);
    }
  }

  writeFileSync(outputPath, lines.join('\n') + '\n');
  console.log(`\n‚úÖ Exported secrets to: ${outputPath}`);
}

/**
 * Main entry point
 */
async function main() {
  const args = process.argv.slice(2);
  const checkOnly = args.includes('--check');
  const exportEnv = args.includes('--export');

  console.log('üîÑ Doppler Environment Sync');
  console.log('='.repeat(40));

  // Check if Doppler is installed
  const dopplerInstalled = await checkDopplerInstalled();
  if (!dopplerInstalled) {
    console.error('‚ùå Doppler CLI not installed. Install from https://doppler.com/docs/cli');
    console.error('   Or set DOPPLER_TOKEN environment variable directly.');
    process.exit(1);
  }

  // Check for Doppler token
  const dopplerToken = process.env.DOPPLER_TOKEN;
  if (!dopplerToken) {
    console.error('‚ùå DOPPLER_TOKEN not set in environment.');
    console.error('   Set it with: export DOPPLER_TOKEN=your_token');
    process.exit(1);
  }

  console.log('üì• Fetching secrets from Doppler...');

  // Fetch secrets (using default project/config or environment variables)
  const project = process.env.DOPPLER_PROJECT || 'requiem';
  const config = process.env.DOPPLER_CONFIG || 'prd';

  const secrets = await fetchDopplerSecrets({ project, config });

  // Validate secrets
  const validation = validateSecrets(secrets);

  if (!validation.valid) {
    console.error(`\n‚ùå Missing required secrets:`);
    for (const key of validation.missing) {
      console.error(`   - ${key}`);
    }
    process.exit(1);
  }

  printSecretsSummary(secrets);

  if (checkOnly) {
    console.log('\n‚úÖ All required secrets are present.');
    process.exit(0);
  }

  if (exportEnv) {
    const outputPath = join(ROOT_DIR, '.env.local');
    exportToEnvFile(secrets, outputPath);
  }

  console.log('\n‚úÖ Doppler sync complete.');
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
